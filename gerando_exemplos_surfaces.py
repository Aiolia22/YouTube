# -*- coding: utf-8 -*-
"""gerando_exemplos_surfaces.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1blqZ0z2OGyDNJppHIoQZPs76GSkaspe3

Desenvolvido por *Anderson Canteli*

***Contato***

**email:** andersonmdcanteli@gmail.com

**Facebook:** https://www.facebook.com/canteli2207

**YouTube:** https://www.youtube.com/c/AndersonCanteli

**Instagram:** https://www.instagram.com/canteli2207/

**GitHub:** https://github.com/Aiolia22/

**Site:** https://andersoncanteli.wordpress.com/

Importing sugar, spice, and everything nice
"""

from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.ticker import LinearLocator, FormatStrFormatter
import numpy as np


# Lista com o nome das paletas disponíveis em https://matplotlib.org/3.3.2/tutorials/colors/colormaps.html
# PS: a paleta 'turbo' (Miscelaneous) não esta funcionando corretamente, e por isso foi removida

# Descomente (Ctrl + /) uma das opções para que os gráficos sejam gerados
# Os arquivos são salvos no ambiente Colab iterativamente 
# Os arquivos são baixados para o seu PC automaticamente

# # ['Perceptually Uniform Sequential']
#paletas = ['viridis', 'plasma', 'inferno', 'magma', 'cividis']

# # ['Sequential']
# paletas = ['Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds',
#             'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu',
#             'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn']

# # ['Sequential (2)'] 
# paletas = ['binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink',
#             'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia',
#             'hot', 'afmhot', 'gist_heat', 'copper']

# # ['Diverging'] 
# paletas = ['PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu',
#             'RdYlBu', 'RdYlGn', 'Spectral', 'coolwarm', 'bwr', 'seismic']

# # ['Cyclic']
# paletas = ['twilight', 'twilight_shifted', 'hsv']

# #  ['Qualitative']
# paletas = ['Pastel1', 'Pastel2', 'Paired', 'Accent',
#                         'Dark2', 'Set1', 'Set2', 'Set3',
#                         'tab10', 'tab20', 'tab20b', 'tab20c']

# # ['Miscellaneous'] 
# paletas = ['flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern',
#             'gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg',
#             'gist_rainbow', 'rainbow', 'jet', 'nipy_spectral',
#             'gist_ncar']

# Loop para iterar ao longo de todas as paletas
for j in range(len(paletas)):
  paleta = paletas[j]
  # Criando o canvas da figura
  fig = plt.figure(figsize=(12,10)) # criando uma instancia para o gráfico 3D
  ax = fig.gca(projection='3d') # criando os eixos do gráfico 3D

  ## Entrando com os dados do MODELO

  intervalo_x = (-1.1, 1.1) # intervalo de valores de X
  intervalo_y = (-1.1, 1.1) # intervalo de valores de Y
  n_valores = 50 # numero de valores gerados. Importante que X e Y tenham o mesmo tamanho
  X = np.linspace(intervalo_x[0],intervalo_x[1],n_valores,True) # gerando dados para o eixo X. 
                                                                # O primeiro deve ser o limite inferior da equação, 
                                                                # o segundo  deve ser o limite superior da equação
                                                                # o terceiro é o número de pontos que serão criados. Quanto mais pontos, mais precisa fica a 
                                                                #superfície, mas mais pesada fica a figura
                                                                # o quarto confirma que o último valor do intervalo será incluido

  Y = np.linspace(intervalo_y[0],intervalo_y[1],n_valores,True) # gerando dados para o eixo Y. 
                                                                # Exatamente a mesma coisa do eixo Y 

  X, Y = np.meshgrid(X, Y) # Criando a malha de combinações possiveis entre X e Y

  # Calculando os valores de Z, utilizando a equação do modelo
  Z = 24.95 - 6.54*X - 3.88*Y 

  # Escolhendo a paleta de cores
  # Criando um título para o gráfico. Neste caso, estou colocando a equação do modelo como título
  title = "Colormap: cm." + paleta

  ## Nomes do eixo com formatação LATEX
  # Nome do eixo X:
  x_label = r"$Temperature \quad (°C)$"  # sem latex: x_label = "Temperature (°C)"
  # Nome do eixo Y:
  y_label = r"$pH$"                      # sem latex: y_label = "pH"
  # Nome do eixo Z:
  z_label = r"$q_t \quad (mg/g)$"        # sem latex: z_label = "qt (mg/g)"

  # Gerando a superfície
  surf = ax.plot_surface(X, Y, Z,             # os três primeiros argumentos são os eixos X, Y e Z. Não altere
                        cmap= paleta,        # este argumento é a paleta de cores do mapa. Não altere
                        linewidth=0.2,       # este argumento é a espessura das linhas de grid sob a superfície.
                        edgecolor="k",       # este artumento é a cor das linhas  grid sob a superfície
                        antialiased=True,    # argumento para suavizar a figura. Importante manter True especialmente para malhas muito grandes
                        rstride=2,           # tamanho do retangulo que faz o grid (linha)
                        cstride=2,           # tamanho do retangulo que faz o grid (coluna)
                        shade=False,         # adicionar sombra ao plot. Recomendado manter False
                        alpha=1,            # Transparência da figura. Recomendado menor do 1 quando tem dados experimentais
                        ) 

  # Alterando o intervalor de ploatagem do gráfico
  ax.set_xlim(intervalo_x[0],intervalo_x[1]) # exatamente o mesmo intervalo utilizado para gerar a superficie
  ax.set_ylim(intervalo_y[0],intervalo_y[1]) # exatamente o mesmo intervalo utilizado para gerar a superficie
  ax.set_zlim(0, np.max(Z))                  # Fixando em 0, pois geralmente não temos valores negativos para a variavel resposta, mas que começa em 0.

  # Editando o eixo Z
  ax.zaxis.set_major_locator(LinearLocator(10))               # Número de linhas marcadas no eixo Z
  ax.zaxis.set_major_formatter(FormatStrFormatter('%.01f'))   # Formatando o número de casas decimais após a virgula no eixo Z

  ## Adicionando o contorno da superficie em um (ou mais) eixo específico. Recomendado apenas no eixo Z
  #Adicionando no eixo Z
  ax.contourf(X, Y, Z, zdir='z',  offset=0, cmap=paleta)
  ##Adicionando no eixo X
  #ax.contourf(X, Y, Z, zdir='x', offset=0, cmap=paleta)
  ##Adicionando no eixo Y
  #ax.contourf(X, Y, Z, zdir='y', offset=0, cmap=paleta)

  # Escolhendo uma cor para o fundo do gráfico
  BACKGROUD_COLOR = (1.0, 1.0, 1.0) #deve ser uma tupla, contendo 3 valores decimais entre 0.0 e 1.0. Defalut é branco (1.0,1.0,1.0)

  ax.w_xaxis.set_pane_color(BACKGROUD_COLOR) # alterando cor de fundo eixo x
  ax.w_yaxis.set_pane_color(BACKGROUD_COLOR) # alterando cor de fundo eixo y
  ax.w_zaxis.set_pane_color(BACKGROUD_COLOR) # alterando cor de fundo eixo z

  # Deixando o fundo do gráfico transparente
  ax.xaxis.pane.fill = True # Mude para False para dexair transparente
  ax.yaxis.pane.fill = True # Mude para False para dexair transparente
  ax.zaxis.pane.fill = True # Mude para False para dexair transparente

  # Alterando a cor da linhas limites do gráfico
  # Opções: "b": blue. "g": green. "r": red. "c": cyan. "m": magenta. "y": yellow. "k": black. "w": white.
  ax.xaxis.pane.set_edgecolor('k') # cor eixo x
  ax.yaxis.pane.set_edgecolor('k') # cor eixo y
  ax.zaxis.pane.set_edgecolor('k') # cor eixo z


  # Alterando o nome dos eixos
  FONT_SIZE = 18 # tamanho de fone padronizada

  # eixo X
  ax.set_xlabel(x_label, fontsize=FONT_SIZE) # adicionando nome no eixo X, com fonte de tamanho FONT_SIZE
  ax.xaxis.labelpad = 10 # adicionando um espaçamento entre o gráfico e o nome no eixo X

  # eixo Y
  ax.set_ylabel(y_label, fontsize=FONT_SIZE) # adicionando nome no eixo Y, com fonte de tamanho FONT_SIZE
  ax.yaxis.labelpad = 10 # adicionando um espaçamento entre o gráfico e o nome no eixo Y

  # eixo Z
  ax.zaxis.set_rotate_label(False) # Removendo a rotação padrão do label em Z
  ax.set_zlabel(z_label, fontsize=FONT_SIZE,  rotation=90) # adicionando nome ao eixo Z, com fonte de tamanho FONT_SIZE e com rotação especificada = 90 °C
  ax.zaxis.labelpad = 10 # adicionando um espaçamento entre o gráfico e o nome no eixo Z

  # Adicionando legendas para as cores
  fig.colorbar(surf,            # o primeiro argumento é a instancia da superficie
              shrink = 0.8,    # tamanho proporcional da barra. Teste diferentes valores para adequação 
              pad = -0.05,     # distancia entre a barra e a superficie. Vloares negativos alteram o tamanho do gráfico, para corrigir, apenas mude o tamanho da figura
              aspect = 10      # formato da barra. Altere entre números inteiros para escolher opções diferentes
              )


  plt.title(title,            # nome do titulo
            fontsize=22,      # tamanho da fonte
            pad=20            # espaçamento entre o gráfico e o titulo
            )    

  # Escolhendo a vista da figura
  ax.view_init(30,45) # primeiro argumento é a rotação em X, segundo argumento é a rotação em Y

  # Removendo espaçamentos desnecessários
  fig.tight_layout(pad=0) # caso queira dar um espaçamento específico, altere o pad

  # salvando a figura a cada loop
  plt.savefig("superficie_" + paleta + ".png", # nome do arquivo com a extensão (.png, .tif, .pdf, .jpg, .svg, entre outras)
              dpi=300,      # quantidade de dpis
              transparent=False # determinar que a figura seja transparente. Altere para False se não queria que a figura fique transparente
              )

  plt.show() # mostrando a figura :D

  # baixando cada figura a cada loop


